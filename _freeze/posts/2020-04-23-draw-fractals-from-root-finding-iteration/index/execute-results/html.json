{
  "hash": "ff64d0eea42cd83009d25fe7a49dfe46",
  "result": {
    "markdown": "---\ntitle: \"Zoom Talk Draw Fractals from Root Finding Iterations\"\ndescription: \"use NewtonRaphson root finding methods to draw fractals for complex functions\"\ndate: '2020-04-23'\ncategories:\n  - presentations\n  - r\n---\n\n\n![](https://raw.githubusercontent.com/XUKEREN/Draw-fractals-from-root-finding-iteration-in-R/master/README_files/figure-gfm/unnamed-chunk-7-9.png)\n\n\n\n\n  \nI gave a zoom talk about drawing fractals in R for the LA R Users April Meetup.     \n\nYouTube recording: [<img src=\"../../imgs/link.png\" style=\"min-width:5%;max-width:30px;\" alt=\" \" />](https://www.youtube.com/watch?v=dFA4qsJuIVs)  \n\nGithub repo: [<img src=\"../../imgs/github.svg\" style=\"min-width:5%;max-width:30px;\" alt=\" \" />](https://github.com/XUKEREN/Draw-fractals-from-root-finding-iteration-in-R)\n\n## Samples codes: \n\nUse NewtonRaphson root finding methods to draw fractals for complex functions.  \n\nCreate function newtonraphson  \n\n::: {.cell}\n\n```{.r .cell-code}\n# ftn is the name of a function that has two output including f(x) and f'(x)\n# x0 is the starting point for the algorithm\n# tol is a good stop condition when |f(x)| <= tol for the algorithm, the default here is 1e-9\n# max.iter is a stop condition for the algorithm when n = max.itr\n\nnewtonraphson <- function(ftn, x0, tol = 1e-9, max.iter) {\n  # initialize\n  x <- x0\n  fx <- ftn(x)\n  iter <- 0\n\n  # continue iterating until stopping conditions are met\n  while ((abs(fx[1]) > tol) && (iter < max.iter)) {\n    x <- x - fx[1] / fx[2]\n    fx <- ftn(x)\n    iter <- iter + 1\n    # cat(\"At iteration\", iter, \"value of x is:\", x, \"\\n\")\n  }\n\n  # output depends on the success of the algorithm\n  if (abs(fx[1]) > tol) {\n    # cat(\"Algorithm failed to converge\\n\")\n    return(data.frame(x0, root = NA, iter = NA))\n  } else {\n    # cat(\"Algorithm converged\\n\")\n    return(data.frame(x0, root = x, iter))\n  }\n}\n```\n:::\n\n\n\nDraw graph for `x^3-1`  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nF1 <- function(x) {\n  return(c(x^3 - 1, 3 * (x^2)))\n}\n\n# create complex numbers\nx <- seq(-1, 1, length.out = 500)\ny <- seq(-1, 1, length.out = 500)\nz <- outer(x, 1i * y, \"+\")\n\n# parallel processing using furrr\nplan(multiprocess)\n\ndf <- z %>% future_map_dfr(~ newtonraphson(F1, ., 1e-9, 40), .progress = TRUE)\n\ndf$x <- Re(df$x0)\ndf$y <- Im(df$x0)\n\n# color by iteration\ndf %>% ggplot(aes(x = x, y = y)) +\n  geom_raster(aes(fill = iter), interpolate = TRUE) +\n  scale_fill_gradientn(colors = brewer.pal(12, \"Paired\")) +\n  theme_void() +\n  theme(legend.position = \"none\")\n\ndf %>% ggplot(aes(x = x, y = y)) +\n  geom_raster(aes(fill = iter), interpolate = TRUE) +\n  scale_fill_gradientn(colors = carto.pal(\"multi.pal\")) +\n  theme_void() +\n  theme(legend.position = \"none\")\n\ndf %>% ggplot(aes(x = x, y = y)) +\n  geom_raster(aes(fill = iter), interpolate = TRUE) +\n  scale_fill_gradientn(colors = carto.pal(\"turquoise.pal\")) +\n  theme_void() +\n  theme(legend.position = \"none\")\n\ndf %>% ggplot(aes(x = x, y = y)) +\n  geom_raster(aes(fill = iter), interpolate = TRUE) +\n  scale_fill_gradientn(colors = wes_palette(\"BottleRocket2\")) +\n  theme_void() +\n  theme(legend.position = \"none\")\n\ndf %>% ggplot(aes(x = x, y = y)) +\n  geom_raster(aes(fill = iter), interpolate = TRUE) +\n  scale_fill_gradientn(colors = wes_palette(\"Rushmore1\")) +\n  theme_void() +\n  theme(legend.position = \"none\")\n```\n:::\n\n\n\nSample codes for Secant method  \n\n::: {.cell}\n\n```{.r .cell-code}\nsecant <- function(ftn, x0, x1, tol = 1e-9, max.iter) {\n  # initialize\n  x_n0 <- x0\n  x_n1 <- x1\n  ftn_n0 <- ftn(x_n0)\n  ftn_n1 <- ftn(x_n1)\n  iter <- 0\n\n  # continue iterating until stopping conditions are met\n  while ((abs(ftn_n1) > tol) && (iter < max.iter)) {\n    x_n2 <- x_n1 - ftn_n1 * (x_n1 - x_n0) / (ftn_n1 - ftn_n0)\n    x_n0 <- x_n1\n    ftn_n0 <- ftn(x_n0)\n    x_n1 <- x_n2\n    ftn_n1 <- ftn(x_n1)\n    iter <- iter + 1\n    # cat(\"At iteration\", iter, \"value of x is:\", x_n1, \"\\n\")\n  }\n\n  return(c(x_n1, iter))\n}\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}