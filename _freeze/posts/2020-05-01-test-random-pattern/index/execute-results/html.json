{
  "hash": "a9fd7683dbafeeea91a28bce24d7d0a3",
  "result": {
    "markdown": "---\ntitle: \"Test Random Pattern\"\ndescription: \"We have three grids available showing different patterns. How to test if the pattern is randomly distributed?\"\ndate: '2020-05-01'\ncategories:\n  - notes\n  - r\n---\n\n\n![](../../imgs/unnamed-chunk-2-1.png)  \n\n\n\n\n\nload packages  \n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(knitr)\nlibrary(spatstat)\ntheme_set(theme_minimal())\n```\n:::\n\n\n\nWe have three grids available showing different patterns. How to test if the pattern is randomly distributed?     \n\nFirst I extracted all points with value of one and coded their coordinates: x-coordinate is the row number and y-coordinate is the column number. Then I got a list of points with their cooordinates. I converted this new data frame to a spatial ppp object.  The problem becomes to test for complete spatial randomness (CSR). I chose to use K-function to test CSR. K function is defined as $K(h) = \\frac{1}{\\lambda}E$ $\\lambda$ here represents the intensity of events within distance h. E here is the number of events.  In order to estimate the k-function, we can construct a cricle of radius h around each point event(i), count the number of each events(j) that fall inside this circle and repeat these two steps for all points(i) and sum up results.  $\\hat K(h) = \\frac{R}{n^2}\\sum\\sum_{i\\neq j}\\frac{I_h(d_{ij})}{W_{ij}}$. Here R is the area, n is the number of points, $I_h(d_{ij})$ equals 1 if $d_{ij} \\leq h$, and 0 otherwise, $W_{ij}$ is the edge correction  - the proportion of circumferences of circle = 1  if whole circle in the study area).   Under the assumption of CSR, the expected number of events within distance h of an event is $K(h) = \\pi h^2$. $K(h) < \\pi h^2$ if point pattern is regular and $K(h) > \\pi h^2$ if point pattern is clustered.   I used envelope function to help calculate the K(h) for observed grid. Also I did 99 simulation - created 99 random patterns, and caculated K(h) for each iteration.    Monte Carlo method was used to compute confidence interval. Since there is 99 simiulation, the significance level is 1/(99 + 1) which is 0.01.   If the observed K(h) is above the upper bound of the confidence interval, the grid is showing some clustered patterns.  If the observed K(h) is within the confidence interval, the grid is showing random pattern. In order to perform 99 simulations, I created a function called random_pattern_generator. First, I randomly sampled 0 or 1 for each random point that I want. Then I converted this vector to a matrix. Points with value of 1 form the random pattern that I desire.  \n\n```\nrandom_pattern_generator <- function(a){\ntemp_v <- sample(c(0, 1), a*a, replace = T)   \ntemp_df <- data.frame(matrix(temp_v , a, a))\nsimdata <- data.frame(x = coordinate(temp_df)$x, y = coordinate(temp_df)$y) %>% filter(!is.na(x)) \nsimdata_rr = ppp(simdata$x, simdata$y, window = owin(c(1,a),c(1,a)))\nsimdata_rr\n}\n```\n\nHere, grid 1 and grid 2 are showing random patterns and grid 3 is showing clustering.   \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- read.table(\"./Grid1.txt\", header = FALSE)\n\ndim(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25 25\n```\n:::\n\n```{.r .cell-code}\n# create a function to extract coordinates\n\ncoordinate <- function(database) {\n  # create blank vectors to store value\n  x <- rep(0, dim(database)[1] * dim(database)[2])\n  y <- rep(0, dim(database)[1] * dim(database)[2])\n\n  for (i in 1:dim(database)[1]) {\n    for (j in 1:dim(database)[2]) {\n      if (database[i, j] == 0) {\n        x[(i - 1) * dim(database)[2] + j] <- NA\n        y[(i - 1) * dim(database)[2] + j] <- NA\n      }\n      if (database[i, j] == 1) {\n        x[(i - 1) * dim(database)[2] + j] <- i\n        y[(i - 1) * dim(database)[2] + j] <- j\n      }\n    }\n  }\n  list(x = x, y = y)\n}\n\nmydata <- data.frame(x = coordinate(df)$x, y = coordinate(df)$y)\n\nmydata <- mydata %>% filter(!is.na(x))\n\n# visualize the grid\nggplot(mydata, aes(x = x, y = y)) +\n  geom_point() +\n  scale_x_continuous(breaks = seq(1, 25, 1)) +\n  scale_y_continuous(breaks = seq(1, 25, 1)) +\n  labs(title = \"Grid 1\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# number of points\n\nprint(paste(\"Number of points: \", mydata %>% nrow()))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Number of points:  205\"\n```\n:::\n\n```{.r .cell-code}\nn <- mydata %>% nrow()\n\n# create a spatial ppp object\nmydata_rr <- ppp(mydata$x, mydata$y, window = owin(c(1, 25), c(1, 25)))\n\n# Creating multiple random point patterns with n points and within the window\n\nset.seed(2020)\n\n# create a function to select n points randomly within the window\n\nrandom_pattern_generator <- function(a) {\n  temp_v <- sample(c(0, 1), a * a, replace = T)\n  temp_df <- data.frame(matrix(temp_v, a, a))\n  simdata <- data.frame(x = coordinate(temp_df)$x, y = coordinate(temp_df)$y) %>% filter(!is.na(x))\n  simdata_rr <- ppp(simdata$x, simdata$y, window = owin(c(1, a), c(1, a)))\n  simdata_rr\n}\n\nex <- expression(random_pattern_generator(25))\n\n# Calculate the upper and lower boundaries\nres <- envelope(mydata_rr, Kest, nsim = 99, simulate = ex, verbose = FALSE, saveall = TRUE, global = TRUE)\n\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimultaneous critical envelopes for K(r)\nand observed value for 'mydata_rr'\nEdge correction: \"iso\"\nObtained from 99 evaluations of user-supplied expression\nEnvelope based on maximum deviation of K(r) from null value (estimated from a \nseparate set of 99 simulations)\nAlternative: two.sided\nSignificance level of simultaneous Monte Carlo test: 1/100 = 0.01\n............................................................\n      Math.label     Description                            \nr     r              distance argument r                    \nobs   hat(K)[obs](r) observed value of K(r) for data pattern\nmmean bar(K)(r)      sample mean of K(r) from simulations   \nlo    hat(K)[lo](r)  lower critical boundary for K(r)       \nhi    hat(K)[hi](r)  upper critical boundary for K(r)       \n............................................................\nDefault plot formula:  .~r\nwhere \".\" stands for 'obs', 'mmean', 'hi', 'lo'\nColumns 'lo' and 'hi' will be plotted as shading (by default)\nRecommended range of argument r: [0, 6]\nAvailable range of argument r: [0, 6]\n```\n:::\n\n```{.r .cell-code}\nplot(res)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-2.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- read.table(\"./Grid2.txt\", header = FALSE)\n\ndim(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25 25\n```\n:::\n\n```{.r .cell-code}\ncoordinate <- function(database) {\n  # create blank vectors to store value\n  x <- rep(0, dim(database)[1] * dim(database)[2])\n  y <- rep(0, dim(database)[1] * dim(database)[2])\n\n  for (i in 1:dim(database)[1]) {\n    for (j in 1:dim(database)[2]) {\n      if (database[i, j] == 0) {\n        x[(i - 1) * dim(database)[2] + j] <- NA\n        y[(i - 1) * dim(database)[2] + j] <- NA\n      }\n      if (database[i, j] == 1) {\n        x[(i - 1) * dim(database)[2] + j] <- i\n        y[(i - 1) * dim(database)[2] + j] <- j\n      }\n    }\n  }\n  list(x = x, y = y)\n}\n\nmydata <- data.frame(x = coordinate(df)$x, y = coordinate(df)$y)\n\nmydata <- mydata %>% filter(!is.na(x))\n\n# visualize the grid\nggplot(mydata, aes(x = x, y = y)) +\n  geom_point() +\n  scale_x_continuous(breaks = seq(1, 25, 1)) +\n  scale_y_continuous(breaks = seq(1, 25, 1)) +\n  labs(title = \"Grid 2\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# number of points\n\nprint(paste(\"Number of points: \", mydata %>% nrow()))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Number of points:  221\"\n```\n:::\n\n```{.r .cell-code}\nn <- mydata %>% nrow()\n\nlibrary(spatstat)\n\n# create window - a spatial ppp object\nmydata_rr <- ppp(mydata$x, mydata$y, window = owin(c(1, 25), c(1, 25)))\n\n# Creating multiple random point patterns with n points and within the window\n\nset.seed(2020)\n\nrandom_pattern_generator <- function(a) {\n  temp_v <- sample(c(0, 1), a * a, replace = T)\n  temp_df <- data.frame(matrix(temp_v, a, a))\n  simdata <- data.frame(x = coordinate(temp_df)$x, y = coordinate(temp_df)$y) %>% filter(!is.na(x))\n  simdata_rr <- ppp(simdata$x, simdata$y, window = owin(c(1, a), c(1, a)))\n  simdata_rr\n}\n\nex <- expression(random_pattern_generator(25))\n\n# Calculate the upper and lower boundaries\nres <- envelope(mydata_rr, Kest, nsim = 99, simulate = ex, verbose = FALSE, saveall = TRUE, global = TRUE)\n\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimultaneous critical envelopes for K(r)\nand observed value for 'mydata_rr'\nEdge correction: \"iso\"\nObtained from 99 evaluations of user-supplied expression\nEnvelope based on maximum deviation of K(r) from null value (estimated from a \nseparate set of 99 simulations)\nAlternative: two.sided\nSignificance level of simultaneous Monte Carlo test: 1/100 = 0.01\n............................................................\n      Math.label     Description                            \nr     r              distance argument r                    \nobs   hat(K)[obs](r) observed value of K(r) for data pattern\nmmean bar(K)(r)      sample mean of K(r) from simulations   \nlo    hat(K)[lo](r)  lower critical boundary for K(r)       \nhi    hat(K)[hi](r)  upper critical boundary for K(r)       \n............................................................\nDefault plot formula:  .~r\nwhere \".\" stands for 'obs', 'mmean', 'hi', 'lo'\nColumns 'lo' and 'hi' will be plotted as shading (by default)\nRecommended range of argument r: [0, 6]\nAvailable range of argument r: [0, 6]\n```\n:::\n\n```{.r .cell-code}\nplot(res)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-2.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- read.table(\"./Grid3.txt\", header = FALSE)\n\ndim(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25 25\n```\n:::\n\n```{.r .cell-code}\ncoordinate <- function(database) {\n  # create blank vectors to store value\n  x <- rep(0, dim(database)[1] * dim(database)[2])\n  y <- rep(0, dim(database)[1] * dim(database)[2])\n\n  for (i in 1:dim(database)[1]) {\n    for (j in 1:dim(database)[2]) {\n      if (database[i, j] == 0) {\n        x[(i - 1) * dim(database)[2] + j] <- NA\n        y[(i - 1) * dim(database)[2] + j] <- NA\n      }\n      if (database[i, j] == 1) {\n        x[(i - 1) * dim(database)[2] + j] <- i\n        y[(i - 1) * dim(database)[2] + j] <- j\n      }\n    }\n  }\n  list(x = x, y = y)\n}\n\nmydata <- data.frame(x = coordinate(df)$x, y = coordinate(df)$y)\n\nmydata <- mydata %>% filter(!is.na(x))\n\n# visualize the grid\nggplot(mydata, aes(x = x, y = y)) +\n  geom_point() +\n  scale_x_continuous(breaks = seq(1, 25, 1)) +\n  scale_y_continuous(breaks = seq(1, 25, 1)) +\n  labs(title = \"Grid 3\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# number of points\n\nprint(paste(\"Number of points: \", mydata %>% nrow()))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Number of points:  213\"\n```\n:::\n\n```{.r .cell-code}\nn <- mydata %>% nrow()\n\nlibrary(spatstat)\n\n# create window - a spatial ppp object\nmydata_rr <- ppp(mydata$x, mydata$y, window = owin(c(1, 25), c(1, 25)))\n\n\n# Creating multiple random point patterns with n points and within the window\n\nset.seed(2020)\n\nrandom_pattern_generator <- function(a) {\n  temp_v <- sample(c(0, 1), a * a, replace = T)\n  temp_df <- data.frame(matrix(temp_v, a, a))\n  simdata <- data.frame(x = coordinate(temp_df)$x, y = coordinate(temp_df)$y) %>% filter(!is.na(x))\n  simdata_rr <- ppp(simdata$x, simdata$y, window = owin(c(1, a), c(1, a)))\n  simdata_rr\n}\n\nex <- expression(random_pattern_generator(25))\n\n\n# Calculate the upper and lower boundaries\nres <- envelope(mydata_rr, Kest, nsim = 99, simulate = ex, verbose = FALSE, saveall = TRUE, global = TRUE)\n\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimultaneous critical envelopes for K(r)\nand observed value for 'mydata_rr'\nEdge correction: \"iso\"\nObtained from 99 evaluations of user-supplied expression\nEnvelope based on maximum deviation of K(r) from null value (estimated from a \nseparate set of 99 simulations)\nAlternative: two.sided\nSignificance level of simultaneous Monte Carlo test: 1/100 = 0.01\n............................................................\n      Math.label     Description                            \nr     r              distance argument r                    \nobs   hat(K)[obs](r) observed value of K(r) for data pattern\nmmean bar(K)(r)      sample mean of K(r) from simulations   \nlo    hat(K)[lo](r)  lower critical boundary for K(r)       \nhi    hat(K)[hi](r)  upper critical boundary for K(r)       \n............................................................\nDefault plot formula:  .~r\nwhere \".\" stands for 'obs', 'mmean', 'hi', 'lo'\nColumns 'lo' and 'hi' will be plotted as shading (by default)\nRecommended range of argument r: [0, 6]\nAvailable range of argument r: [0, 6]\n```\n:::\n\n```{.r .cell-code}\nplot(res)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-2.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}